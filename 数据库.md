## 💾 数据库

> 本节部分知识点来自《数据库系统概论（第 5 版）》

### 请你说说 MySQL 索引，以及它们的好处和坏处
// https://www.nowcoder.com/exam/interview/detail?questionClassifyId=0&questionId=2412665&questionJobId=161&type=1
索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。
优点：
* 使用索引列查询可以加速查询速度
* 加速排序操作
* 加速分组操作
缺点：
* 使用额外的存储
* 增删改查操作都要对索引进行控制
* 需要对索引知识的掌握，**使用**explain函数对语句进行分析，查看一个语句是否真正使用的索引
### 常用数据模型

* 层次模型（hierarchical model）
* 网状模型（network model）
* 关系模型（relational model）
    * 关系（relation）：一个关系对应通常说的一张表
    * 元组（tuple）：表中的一行即为一个元组
    * 属性（attribute）：表中的一列即为一个属性
    * 码（key）：表中可以唯一确定一个元组的某个属性组
    * 域（domain）：一组具有相同数据类型的值的集合
    * 分量：元组中的一个属性值
    * 关系模式：对关系的描述，一般表示为 `关系名(属性1, 属性2, ..., 属性n)`
* 面向对象数据模型（object oriented data model）
* 对象关系数据模型（object relational data model）
* 半结构化数据模型（semistructure data model）

### 常用 SQL 操作

<table>
  <tr>
    <th>对象类型</th>
    <th>对象</th>
    <th>操作类型</th>
  </tr>
  <tr>
    <td rowspan="4">数据库模式</td>
    <td>模式</td>
    <td><code>CREATE SCHEMA</code></td>
  </tr>
  <tr>
    <td>基本表</td>
    <td><code>CREATE SCHEMA</code>，<code>ALTER TABLE</code></td>
  </tr>
    <tr>
    <td>视图</td>
    <td><code>CREATE VIEW</code></td>
  </tr>
    <tr>
    <td>索引</td>
    <td><code>CREATE INDEX</code></td>
  </tr>
    <tr>
    <td rowspan="2">数据</td>
    <td>基本表和视图</td>
    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>DELETE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>
  </tr>
    <tr>
    <td>属性列</td>
    <td><code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code>，<code>REFERENCES</code>，<code>ALL PRIVILEGES</code></td>
  </tr>
</table>

> SQL 语法教程：[runoob . SQL 教程](http://www.runoob.com/sql/sql-tutorial.html)

### 关系型数据库

* 基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改
* 关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性

#### 索引

#### 聚簇索引和非聚簇索引（二级索引）
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据。 表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。 非聚簇索引：将数据存储与索引分开，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致

#### B+树的结构
B+树是一种多叉树，（出度在100+），在非叶子结点只存储索引，叶子结点存储数据。在每个叶子节点中还会存储两个指针，分别指向顺序上一个节点和下一个节点。

* 1、B+Tree vs B Tree

B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。

另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

* 2、B+Tree vs 二叉树（红黑树）

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

* 3、B+Tree vs Hash

Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。

但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

#### ACID
在数据库中保证**事务**的正常可靠，所以必须遵循的4个原则：
* 原子性（atomicity，或称不可分割性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
* 一致性（consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。确保事务仅以预定义的、可预测的方式对表进行更改。
  * 事务前后，保证不违反数据库约束（唯一约束，唯一约束，外键约束）
  * 保证未来开始的任何事务都必然会看到过去提交的其他事务的影响
  * 业务一致性：转账中的钱不能凭空消失
* 隔离性（isolation，又称独立性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
* 持久性（durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### 事务的隔离级别
事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。

#### 关系型数据库和非关系型数据库
关系模式就是二维表格模型，每一行数据的结构是固定的，提供事务的ACID的保证。
非关系型数据库中不使用固定的二维数据模型，如使用key-value模型，大文本的数据模型，一般不支持事务的ACID的完整支持。

* 数据库索引：顺序索引、B+ 树索引、hash 索引
* [MySQL 索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

### 数据库完整性

* 数据库的完整性是指数据的正确性和相容性。
    * 完整性：为了防止数据库中存在不符合语义（不正确）的数据。
    * 安全性：为了保护数据库防止恶意破坏和非法存取。
* 触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。

### 关系数据理论

* 数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。
* 最重要的数据依赖：函数依赖、多值依赖。

#### 范式

* 第一范式（1NF）：属性（字段）是最小单位不可再分。
* 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键，没有包含在主键里的列必须完全依赖于主键，而不能只依赖主键的一部分
  * （消除 1NF 非主属性对码的部分函数依赖）。
* 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性
  * （消除 2NF 非主属性对码的传递函数依赖）。
* 鲍依斯-科得范式（BCNF）：满足 3NF，任何主属性不能对主键子集依赖
  * （消除 3NF 主属性对码的部分和传递函数依赖）。
* 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。

### 数据库恢复

* 事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。
* 事物的 ACID 特性：原子性、一致性、隔离性、持续性。
* 恢复的实现技术：建立冗余数据 -> 利用冗余数据实施数据库恢复。
* 建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。

### 并发控制

* 事务是并发控制的基本单位。
* 并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。
* 并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。
* 基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。
* 活锁死锁：
    * 活锁：事务永远处于等待状态，可通过先来先服务的策略避免。
    * 死锁：事务永远不能结束
        * 预防：一次封锁法、顺序封锁法；
        * 诊断：超时法、等待图法；
        * 解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。
* 可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。