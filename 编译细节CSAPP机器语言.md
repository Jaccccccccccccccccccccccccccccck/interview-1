
# 编译细节
[toc]


## x86-64的一些仅汇编可见的编程可见状态
* 程序计数器
* 16个整数寄存器文件
* 条件码寄存器
* 一组向量寄存器可以存放一个或多个整数或浮点数

## x86的通用寄存器
* IA32架构时有8个32位寄存器，从eax到esp
* x86-64位时，从rax到rsp，另外新增了8个r8-r15寄存器


## 指令细节
### 代表指令数据大小（b w l q）
* movb 传送字节
* movw 传送字（16位）
* movl 传送双字
* movq 传送四字（64为）

### 对栈的操作
* pushq S // 实际行为
  * R[%rsq] <- R[%rsq]-8
  * M[R[%rsp]] <- S
* popq D
  * D <- M[R[%rsp]]
  * R[%rsp] <- R[%rsp] + 8

### 函数调用栈（x86）
* 假设过程P调用过程Q，call和ret指令的操作行为：
  * call：将返回地址A入栈，并将PC设置成被Q过程首地址 // P的栈帧的栈顶就是返回地址
  * ret：将栈顶的返回地址A pop出来，并把PC设置成A。
    * 在ret指令之前需要把Q栈帧上分配的空间释放掉（rsp减去一个偏移量），此时栈顶已经是A地址了

* 有一个寄存器永远存储着栈顶的地址**rsp**寄存器
* 在32位中**ebp**寄存器用来专门存储帧地址，叫做帧指针寄存器，在x64中废弃了这一用法，rbp变成了一个通用寄存器
  * 在x64上找到帧地址方法：在call Q指令执行后，Q需要记录P中返回后需要执行的代码地址。
* 过程需要的存储空间超出寄存器能存放大小后，就会在栈上分配空间，这一部分成为过程的**栈帧**
* 当前执行的过程的栈帧总是在栈顶
* 过程P调用Q时，会把返回地址入栈，指明当Q过程返回时，要从P程序的哪个位置继续执行，这个返回地址属于P栈帧的一部分
* 过程的参数最多支持6个通过寄存器传递，
  * rdi/rsi/rdx/rcx/r8/r9（dsdc大师点餐89），当参数是不是64位的，通过使用寄存器的低位，用寄存器的的别名例如edi表示